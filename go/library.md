# Library

## `bufio`

    Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer
    object, creating another object (Reader or Writer) that also implements the
    interface but provides buffering and some help for textual I/O.

### `bufio.NewReader`

    func NewReader(rd io.Reader) *Reader
        NewReader returns a new Reader whose buffer has the default size.

### `bufio.Reader`

    type Reader struct {}
        Reader implements buffering for an io.Reader object.

#### `bufio.Reader.ReadRune`

    func (b *Reader) ReadRune() (r rune, size int, err error)
        ReadRune reads a single UTF-8 encoded Unicode character and returns the
        rune and its size in bytes. If the encoded rune is invalid, it consumes
        one byte and returns unicode.ReplacementChar (U+FFFD) with a size of 1.

### `bufio.Scanner`

    type Scanner struct { }
        Scanner provides a convenient interface for reading data such as a file
        of newline-delimited lines of text. Successive calls to the Scan method
        will step through the 'tokens' of a file, skipping the bytes between
        the tokens. The specification of a token is defined by a split function
        of type SplitFunc; the default split function breaks the input into
        lines with line termination stripped. Split functions are defined in
        this package for scanning a file into lines, bytes, UTF-8-encoded
        runes, and space-delimited words. The client may instead provide a
        custom split function.

        Scanning stops unrecoverably at EOF, the first I/O error, or a token
        too large to fit in the buffer. When a scan stops, the reader may have
        advanced arbitrarily far past the last token. Programs that need more
        control over error handling or large tokens, or must run sequential
        scans on a reader, should use bufio.Reader instead.

Example:

    input := bufio.NewScanner(os.Stdin)

#### `bufio.Scanner.Scan`

    func (s *Scanner) Scan() bool
        Scan advances the Scanner to the next token, which will then be
        available through the Bytes or Text method. It returns false when the
        scan stops, either by reaching the end of the input or an error. After
        Scan returns false, the Err method will return any error that occurred
        during scanning, except that if it was io.EOF, Err will return nil.
        Scan panics if the split function returns too many empty tokens without
        advancing the input. This is a common error mode for scanners.

Example:

    input := bufio.NewScanner(os.Stdin)
    for input.Scan() {
        fmt.Println(input.Text())
    }

#### `bufio.Scanner.Text`

    func (s *Scanner) Text() string
        Text returns the most recent token generated by a call to Scan as a
        newly allocated string holding its bytes.

## `builtin`

    Package builtin provides documentation for Go's predeclared identifiers.
    The items documented here are not actually in package builtin but their
    descriptions here allow godoc to present documentation for the language's
    special identifiers.

### `builtin.error`

    type error interface {
        Error() string
    }
        The error built-in interface type is the conventional interface for
        representing an error condition, with the nil value representing no
        error.

#### `builtin.error.Error`

    func Error() string

### `builtin.panic`

    func panic(v interface{})
        The panic built-in function stops normal execution of the current
        goroutine. When a function F calls panic, normal execution of F stops
        immediately. Any functions whose execution was deferred by F are run in
        the usual way, and then F returns to its caller. To the caller G, the
        invocation of F then behaves like a call to panic, terminating G's
        execution and running any deferred functions. This continues until all
        functions in the executing goroutine have stopped, in reverse order. At
        that point, the program is terminated and the error condition is
        reported, including the value of the argument to panic. This
        termination sequence is called panicking and can be controller by the
        built-in function recover.

### `builtin.recover`

    func recover() interface{}
        The recover built-in function allows a program to manage behaviour of a
        panicking goroutine. Executing a call to recover inside a deferred
        function (but not any function called by it) stops the panicking
        sequence by restoring normal execution and retriebes the error value
        passed to the call of panic. If recover is called outside the deferred
        function it will not stop a panicking sequence. In this case, or when
        the goroutine is not panicking, or if the argument supplied to panic
        was nil, recover returns nil. Thus the return value from recover
        reports whether the goroutine is panicking.

## `bytes`

    Package bytes implements functions for the manipulation of byte slices. It
    is analogous to the facilities of the strings package.

### `bytes.Buffer`

    type Buffer struct {}
        A Buffer is a variable-sized buffer of bytes with Read and Write
        methods. The zero value for Buffer is an empty buffer ready to use.

#### `bytes.Buffer.WriteByte`

    func (b *Buffer) WriteByte(c byte) error
        WriteByte appends the byte c to the buffer, growing the buffer as
        needed. The returned error is always nil, but is included to match
        bufio.Writer's WriteByte. If the buffer becomes too large, WriteByte
        will panic with ErrTooLarge.

#### `bytes.Buffer.WriteRune`

    func (b *Buffer) WriteRune(r rune) (n int, err error)
        WriteRune appends the UTF-8 encoding of Unicode code point r to the
        buffer, returning its length and an error, which is always nil but is
        included to match bufio.Writer's WriteRune. The buffer is grown as
        needed; if it becomes too large, WriteRune will panic with ErrTooLarge.

#### `bytes.Buffer.WriteString`

    func (b *Buffer) WriteString(s string) (n int, err error)
        WriteString appends the contents of s to the buffer, growing the buffer
        as needed. The return value n is the length of s; err is always nil. If
        the buffer becomes too large, WriteString will panic with ErrTooLarge.

#### `bytes.Equal`

    func Equal(a, b []byte) bool
        Equal returns a boolean reporting whether a and b are the same length
        and contain the same bytes. A nil argument is equivalent to an empty
        slice.

## `crypto`

    Package crypto collects common cryptographic constants.

### `crypto/sha256`

    Package sha256 implements the SHA224 and SHA256 hash algorithms as defined
    in FIPS 180-4.

#### `crypto/sha256.Sum256`

    func Sum256(data []byte) [Size]byte
        Sum256 returns the SHA256 checksum of the data.

### `crypto/sha512`

    Package sha512 implements the SHA-384, SHA-512, SHA-512/224, and
    SHA-512/256 hash algorithms as defined in FIPS 180-4.

#### `crypto/sha512.Sum384`

    func Sum384(data []byte) [Size]byte
        Sum384 returns the SHA384 checksum of the data.

#### `crypto/sha512.Sum512`

    func Sum512(data []byte) [Size]byte
        Sum512 returns the SHA512 checksum of the data.

## `encoding`

    Package encoding defines interfaces shared by other packages that convert
    data to and from byte-level and textual representations. Packages that
    check for these interfaces include encoding/gob, encoding/json, and
    encoding/xml. As a result, implementing an interface once can make a type
    useful in multiple encodings. Standard types that implement these
    interfaces include time.Time and net.IP. The interfaces come in pairs that
    produce and consume encoded data.

### `encoding/json`

    Package json implements encoding and decoding of JSON as defined in RFC
    7159. The mapping between JSON and Go values is described in the
    documentation for the Marshal and Unmarshal functions.

#### `encoding/json.Decoder`

    type Decoder struct { }
        A Decoder reads and decodes JSON values from an input stream.

##### `encoding/json.Decoder.Decode`

    func (dec *Decoder) Decode(v interface{}) error
        Decode reads the next JSON-encoded value from its input and stores it
        in the value pointed to by v.

#### `encoding/json.Encoder`

    type Encoder struct { }
        An Encoder writes JSON values to an output stream.

##### `encoding/json.Encoder.Encode`

    func (enc *Encoder) Encode(v interface{}) error
        Encode writes the JSON encoding of v to the stream, followed by a
        newline character.

#### `encoding/json.NewDecoder`

    func NewDecoder(r io.Reader) *Decoder
        NewDecoder returns a new decoder that reads from r.

#### `encoding/json.NewEncoder`

    func NewEncoder(w io.Writer) *Encoder
        NewEncoder returns a new encoder that writes to w.

#### `encoding/json.Marshal`

    func Marshal(v interface{}( ([]byte, error)
        Marshal returns the JSON encoding of v.

        Marshal traverses the value v recursively. If an encountered value
        implements the Marshaler interface and is not a nil pointer, MArshal
        calls its MarshalJSON method to produce JSON. [...]

#### `encoding/json.MarshalIndent`

    func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)
        MarshalIndent is like Marshal but applies Indent to format the output.
        Each JSON element in the output will begin on a new line beginning with
        prefix followed by one or more copies of indent according to the
        indentation nesting.

#### `encoding/json.Unmarshal`

    func Unmarshal(data []byte, v interface{}) error
        Unmarshal parses the JSON-encoded data and stores the result in the
        value pointed to by v. If v is nil or not a pointer, Unmarshal returns
        an InvalidUnmarshalError.

## `errors`

    Package errors implements functions to manipulate errors.

### `errors.New`

    func New(text string) error
        New returns an error that formats as the given test.

## `flag`

### `flag.Args`

    func Args() []string
        Args returns the non-flag command-line arguments.

Example:

    flag.Parse()
    args := flag.Args()
    a, b := args[0], args[1]

### `flag.Bool`

    func Bool(name string, value bool, usage string) *bool
        Bool defines a bool flag with specified name, default value, and usage
        string. The return value is the address of a bool variable that stores
        the value of the flag.

Example:

    var n = flag.Bool("n", false, "Whether or not to print a newline")
    // ...
    if (*n) {
        fmt.Println()
    }

### `flag.Parse`

    func Parse()
        Parse parses the command-line flags from os.Args[1:]. Must be called
        after all flags are defined and before flags are accessed by the
        program.

### `flag.String`

    func String(name string, value string, usage string) *string
        String defines a string flag with specified name, default value, and
        usage string. The return value is the address of a string variable that
        stores the value of the flag.

Example:

    var sep = flag.Bool("sep", " ", "Separator to be printed")
    // ...
    fmt.Print(*sep)

## `fmt`

### `fmt.Errorf`

    func Errorf(format string, a ...interface{}) error
        Errorf formats according to a format specifier and returns the string
        as a value that satisfies error.

### `fmt.Fprintf`

    func Fprintf(w io.Writer, format string, a ...interface{} (n int, err error)
        Fprintf formats according to a format specifier and writes to w. It
        returns the number of bytes written and any write error encountered.

Example:

    fmt.Fprintf(os.Stderr, "%v (%T)\n", err, err)

### `fmt.Println`

    func Println(a ...interface{}) (n int, err error)
        Println formats using the default formats for its operands and writes
        to standard output. Spaces are always added between operands and a
        newline is appended. It returns the number of bytes written and any
        write error encountered.

Example:

    fmt.Println("This is a test.")

### `fmt.Printf`

    func Printf(format string, a ...interface{}) (n int, err error)
        Printf formats according to a format specifier and writes to standard
        output. It returns the number of bytes written and any write error
        encountered.

Example

    fmt.Printf("%d / %d = %f", 10, 3, 10/3.0) // 10 / 3 = 3.333333

### `fmt.Scanf`

    func Scanf(format string, a ...interfac{}) (n int, err error)
        Scanf scans text read from standard input, storing successive
        space-separated values into successive arguments as determined by the
        format. It returns the number of items successfully scanned. If that is
        less than the number of arguments, err will report why. Newlines in the
        input must match newlines in the format. The one exception: the verb %c
        always scans the next rune in the input, even if it is a space (or tab
        etc.) or newlie.

### `fmt.Sprint`

    func Sprint(a ...interface{}) string
        Sprint formats using the default formats for its operands and returns
        the resulting string. Spaces are added between operands when neither is
        a string.

### `fmt.Sprintf`

    func Sprintf(format string, a ...interface{}) string
        Sprintf formats according to a format specifier and returns the
        resulting string.

## `image`

### `image.NewPaletted`

    func NewPaletted(r Rectangle, p color.Palette) *Paletted
        NewPaletted returns a new Paletted image with the given width, height
        and palette.

Example:

    rectangle := image.Rect(0, 0, 8, 8)
    palette := []color.Color{color.White, color.Black}
    image := image.NewPaletted(rectangle, palette)

### `image.Paletted`

    type Paletted struct {
        // Pix holds the image's pixels, as palette indices. [...]
        Pix []uint8
        
        // Stride is the Pix stride (in bytes) between vertically adjacent
        // pixels.
        Stride int

        // Rect is the image's bounds.
        Rect Rectangle

        // Palette is the image's palette.
        Palette color.Palette
    }
        Paletted is an in-memory image of uint8 indices into a given palette.

#### `image.Paletted.SetColorIndex`

    func (p *Paletted) SetColorIndex(x, y int, index uint8)
        Sets the color of the Point(x,y) to the color at the given index.

Example:

    rectangle := image.Rect(0, 0, 8, 8)
    palette := []color.Color{color.White, color.Black}
    img := image.NewPaletted(rect, palette)
    img.SetColorIndex(3, 7, 1) // set the color at (3,7) to color.Black

### `image.Rectangle`

    type Rectangle struct {
        Min, Max Point
    }
        A Rectangle contains the points with Min.X <= X < Max.X, Min.Y <= Y <
        Max.Y. It is well-formed if Min.X <= Max.X and likewise for Y. Points
        are always well-formed A rectangle's methods always return well-formed
        outputs for well-formed inputs.

        A Rectangle is also an Image whose bounds are the rectangle itself. At
        returns color.Opaque for points in the rectangle and color.Transparent
        otherwise.

### `image.Rect`

    func Rect(x0, y0, x1, y1 int) Rectangle
        Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}. The returnes
        rectangle has minimum and maximum coordinates swapped if necessary so
        that it is well-formed.

Example:

    r := image.Rect(0, 0, 128, 128) // (0,0)-(128,128)

### `image/color`

#### `image/color.Color`

    type Color interface { }

##### `image/color.White`, `image/color.Black` etc.

Standard colors.

##### `image/color.Color.RGBA`

    func RGBA() (r, g, b, a uint32)
        RGBA returns the alpha-premultiplied red, green, blue and alpha values
        for the color. Each value ranges within [0, 0xffff], but is represented
        by a uint32 so that multiplying by a blend factor up to 0xffff will not
        overflow.

        An alpha-premultiplied color component c has been scaled by alpha (a),
        so has valid values 0 <= c <= a.

Example:

    var (
        red   = color.RGBA{0xff, 0, 0, 0xff}
        green = color.RGBA{0, 0xff, 0, 0xff}
        blue  = color.RGBA{0, 0xff, 0, 0xff}
    )

#### `image/color.Palette`

    type Palette []Color
        Palette is a palette of colors.

### `image/gif`

#### `image/gif.GIF`

    type GIF struct {
        // The successive images.
        Image           []*image.Paletted   

        // The successive delay times, one per frame, in 100ths of a second.
        Delay           []int               

        // The loop count.
        LoopCount       int

        // Disposal is the successive disposal methods, one per frame. [...]
        Disposal        []byte

        // Config is the global color table (palette), width and height. [...]
        Config          image.Config

        // BackgroundIndex is the background index in the global color table,
        // for use with the DisposalBackground disposal method.
        BackgroundIndex byte
    }
        GIF represents the possibly multiple images stored in a GIF file.

Example: A 2x2 square with a black pixel switching from top-left to bottom-right.

	animation := gif.GIF{LoopCount: 2}
	rectangle := image.Rect(0, 0, 2, 2)
	palette := []color.Color{color.White, color.Black}

	// first image:
	// B W
	// W W
	image1 := image.NewPaletted(rectangle, palette)
	image1.SetColorIndex(0, 0, 1)
	image1.SetColorIndex(0, 1, 0)
	image1.SetColorIndex(1, 0, 0)
	image1.SetColorIndex(1, 1, 0)
	animation.Delay = append(animation.Delay, 50)
	animation.Image = append(animation.Image, image1)

	// second image:
	// W W
	// W B
	image2 := image.NewPaletted(rectangle, palette)
	image2.SetColorIndex(0, 0, 0)
	image2.SetColorIndex(0, 1, 0)
	image2.SetColorIndex(1, 0, 0)
	image2.SetColorIndex(1, 1, 1)
	animation.Delay = append(animation.Delay, 50)
	animation.Image = append(animation.Image, image2)

	gif.EncodeAll(os.Stdout, &animation)

### `image.Config`

    type Config struct {
        ColorModel      color.Model
        Width, Height   int
    }
        Config holds an image's color model and dimensions.

#### `image/gif.EncodeAll`

    func EncodeAll(w io.Writer, g *GIF) error
        EncodeAll writes the images in g to w in GIF format with the given loop
        count and delay between frames.

## `io`

### `io.Copy`

    func Copy(dst Writer, src Reader) (written int64, err error)
        Copy copies from src to dst until either EOF is reached on src or an
        error occurs. It returns the number of bytes copied and the first error
        encountered while copying, if any.

        A successful Copy returns err == nil, not err == EOF. Because Copy is
        defined to read from src until EOF, it does not treat an EOF from Read
        as an error to be reported.

        If src implements the WriterTo interface, the copy is implemented by
        calling src.WriteTo(dst). Otherwise, if dst implements the ReaderFrom
        interface, the copy is implemented by calling dst.ReadFrom(src).

### `io.EOF`

    var EOF = errors.New("EOF")
        EOF is the error returned by Read when no more input is available.
        Functions should return EOF only to signal a graceful end of input. If
        the EOF occurs unexpectedly in a structured data stream, the
        appropriate error is either ErrUnexpectedEOF or some other error giving
        more detail.

### `io.ReadCloser`

    type ReadCloser interface {
        Reader
        Closer
    }
        ReadCloser is the interface that groups the basic Read and Close
        methods.

### `io.Writer`

    type Writer interface {
        Write(p []byte) (n int, err error)
    }
        Writer ist the interface that wraps the basic Write method.

#### `io.Writer.Write`

    func Write(p []byte) (n int, err error)
        Write writes len(p) bytes from p to the underlying data stream. It
        returns the number of bytes written from p (0 <= n <= len(p)) and any
        error encountered that caused the write to stop early. Write must
        return a non-nil error if it returns n < len(p). Write must not modify
        the slice data, even temporarily.

### `io/ioutil`

#### `ioutil.Discard`

    var Discard io.Writer = devNull(0)
        Discard is an io.Writer on which all Write calls succeed without doing
        anything.

#### `io/ioutil.ReadAll`

    func ReadAll(r io.Reader) ([]byte, error)
        ReadAll reads from r until an error or EOF and returns the data it
        read. A successful call returns err == nil, not err == EOF. Because
        ReadAll is defined to read from src until EOF, it does not treat an EOF
        from Read as an error to be reported.

#### `io/ioutil.ReadFile`

    func ReadFile(filename string) ([]byte, error)
        ReadFile reads the file named by filename and returns the contents. A
        successful call returns err == nil, not err == EOF. Because ReadFile
        reads the whole file, it does not treat an EOF from Read as an error to
        be reported.

## `log`

    Package log implements a simple logging package.

### `log.Fatal`

    func Fatal(v ...interface{})
        Fatal is equivalent to Print() followed by a call to os.Exit(1).

### `log.Fatalf`

    func Fatalf(format string, v ...interface{})
        Fatalf is equivalent to Printf() followed by a call to os.Exit(1).

### `log.Flags`

    func Flags() int
        Flags returns the output flags for the standard logger.

### `log.Print`

    func Print(v ...interface{})
        Print calls Output to print to the standard logger. Arguments are
        handled i the manner of fmt.Print.

### `log.SetFlags`

    func SetFlags(flag int)
        SetFlags sets the output flags for the standard logger.

### `log.SetPrefix`

    func SetPrefix(prefix string)
        SetPrefix sets the output prefix for the standard logger.

### Flags

- `Ldate`: the date in the local time zone
- `Ltime`: the time in the local time zone
- `Lmicroseconds`: microsecond resolution
- `Llongfile`: full file name and line number
- `Lshortfile`: final file name element and line number
- `LUTC`: if Ldate or Ltime is set, use UTC rather than the local time zone
- `LstdFlags = Ldate | Ltime`: initial values for the standard logger

The fields are to be set using or logic:

    log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)

## `math`

### `math/big`

    Package big implements arbitrary-precision arithmetic (big numbers). The
    following numeric types are supported:

        Int     signed integers
        Rat     rational numbers
        Float   floating-point numbers

#### `math/big.Float`

    type Float struct { }
        A nonzero finite Float represents a multi-precision floating point
        number.

##### `math/big.NewFloat`

    func NewFloat(x float64) *Float
        NewFloat allocates and returns a new Float set to x, with precision 53
        and rounding mode ToNearestEven. NewFloat p anics with ErrNaN if x is a
        NaN.

##### `math/big.Float.Add`

    func (z *Float) Add(x, y *Float) *Float
        Add sets z to the rounded sum x+y and returns z. If z's precision is 0,
        it is changed to the larger of x's or y's precision before the
        operation.

##### `math/big.Float.Float64`

    func (x *Float) Float64() (float64, Accuracy)
        Float64 returns the float64 value nearest to x.

##### `math/big.Float.Mul`

    func (z *Float) Mul(x, y *Float) *Float
        Mul sets z to the rounded product x*y and returns z. Precision,
        rounding, and accuracy reporting are as for Add. Mul panics with ErrNaN
        if one operand is zero and the other operand an infinity. The value of
        z is undefined in that case.

##### `math/big.Float.Sqrt`

    func (z *Float) Sqrt(x *Float) *Float
        Sqrt sets z to the rounded square root of x, and returns it.

#### `math/big.Rat`

    type Rat struct { }
        A Rat represents a quotient a/b of arbitrary precision. The zero value
        for a Rat represents the value 0.

##### `math/big.NewRat`

    func NewRat(a, b int64) *Rat
        NewRat creates a new Rat with numerator a and denominator b.

##### `math/big.Rat.Add`

    func (z *Rat) Add(x, y *Rat) *Rat
        Add sets z to the sum x+y and returns z.

##### `math/big.Rat.Float64`

    func (x *Rat) Float64() (f float64, exact bool)
        Float64 returns the nearest float64 value for x and a bool indicating
        whether f represents x exactly.

##### `math/big.Rat.Mul`

    func (z *Rat) Mul(x, y *Rat) *Rat
        Mul sets z to the product x*y and returns z.

### `math/cmplx`

Package cmplx provides basic constants and mathematical functions for complex
numbers.

#### `math/cmplx.Abs`

    func Abs(x complex128) float64
        Abs returns the absolute value (also called the modulus) of x.

Example:

    c := 1 + 1i
    a := cmplx.Abs(c) // 1.4142135623730951

#### `math/cmplx.Sqrt`

    func Sqrt(x complex128) complex128
        Sqrt returns the square root of x. The result r is chosen so that
        eral(r) ≥ 0 and imag(r) has the same sign as imag(x). 

Example:

    c := cmplx.Sqrt(-1) // (0+1i)

### `math.Cos`

    func Cos(x float64) float64
        Cos returns the cosine of the radian argument x.

Example:

    math.Cos(90) // -0.4480736161291701

### `math.Hypot`

    func Hypot(p, q float64) float64
        Hypot returns Sqrt(p*p, q*q), taking care to avoid unnecessary overflow
        and underflow.

Example:

    // Pythagoras: 3² + 4² = 5²
    a := 3.0
    b := 4.0
    c := math.Hypot(a, b)
    // c == 5.0

### `math.Pi`

    Pi  = 3.14159265358979323846264338327950288419716939937510582097494459

Definition: https://oeis.org/A000796

### `math.Sin`

    func Sin(x float64) float64
        Sin returns the sine of the radian argument x.

Example:

    math.Sin(90) // 0.893996663600558

### `math/rand`

### `math/rand.Float64`

    func Flaot64() float64
        Float 64 returns, as a float64, a pseudo-random number in [0.0,1.0)
        from the default Source.

## `net`

### `net/http`

#### `net/http.Get`

    func Get(url string) (resp *Response, err error)
        Get issues a GET to the specified URL. If the response is one of the
        following redirect codes, Get follows the redirect, up to a maximum of
        10 redirects:

        301 (Moved Permanently)
        302 (Found)
        303 (See Other)
        307 (Temporary Redirect)
        308 (Permanent Redirect)

        An error is returned if there were to many redirects or if there was an
        HTTP protocol error. A non-2xx response doesn't cause an error.

        When err is nil, resp always contains a non-nil resp.Body. Caller
        should close resp.Body when done reading from it.

        Get is a wapper around DefaultClient.Get.

        To make a request with custom headers, use NewRequest and
        DefaultClient.Do.

#### `net/http.HandleFunc`

    func HandleFunc(pattern string, handler func(ResponseWriter, *Request))
        HandleFunc registers the handler function for the given pattern in the
        DefaultServeMux. The documentation for ServeMux explains how patterns
        are matched.

#### `net/http.Header`

    type Header map[string][]string
        A Header represents the key'value pairs in an HTTP header.

#### `net/http.ListenAndServe`

    func ListenAndServe(addr string, handler Handler) error
        ListenAndServe listens on the TCP network address addr and then calls
        Serve with handler to handle requests on incoming connections. Accepted
        connections are configured to enable TCP keep-alives. Handler is
        typically nil, in which case the DefaultServeMux is used.

#### `net/http.Request`

    type Request struct {
        // Method specifies the HTTP method (GET, POST, PUT, etc.).
        // For client requests an empty string means GET.
        Method              string

        // URL specifies either the URI being requested (for server requests)
        // for the URL to access (for client requests).
        URL                 *url.URL

        // The protocol version for incoming server requests.
        Proto               string
        ProtoMajor          int
        ProtoMinor          int

        // Header contains the request header fields either received by the
        // server or to be sent by the client.
        Header              header

        Body                io.ReadCloser
        GetBody             func() (io.ReadCloser, error)
        ContentLength       int64
        TransferEncoding    []string
        Close               bool

        // For server requests Host specifies the host on which the URL is
        // sought. Per RFC 2616, this is either the value of the "Host" header or
        // the host name given in the URL itself. It may be of the form
        // "host:port". For international domain names, Host may be in Punycode or
        // Unicode form. Use golang.org/x/net/idna to convert it to either format
        // if needed.
        Host                string

        // Form contains the parsed form data, including both the URL field's
        // query parameters and the POST or PUT form data. This field is only
        // available after ParseForm is called. The HTTP client ignores Form and
        // uses Body instead.
        Form                url.Values

        PostForm            url.Values
        MultipartForm       *multipart.Form
        Trailer             Header

        // RemoteAddr allows HTTP servers and other software to record the
        // network address that sent the request, usually for logging. This field
        // is not filled in by ReadRequest and has no defined format. The HTTP
        // server in this package sets RemoteAddr to an "IP:port" address before
        // invoking a handler.
        RemoteAddr          string

        RequestURI          string
        TLS                 *tls.ConnectionState
        Cancel              <-chan struct{}
        Response            *Response
    }
        A Request represents an HTTP request received by a server or to be sent
        by a client.

        The field semantics differ slightly between client and server usage. In
        addition to the notes on the fields below, see the documentation for
        Request.Write and RoundTripper.

##### `net/http.Request.ParseForm`

    func (r *Request) ParseForm() error
        ParseForm populates r.Form and r.PostForm.

        For all requests, ParseForm parses the raw query from the URL and
        updates r.Form.

#### `net/http.Response`

    type Response struct {
        // e.g. "200 OK"
        Status              string
        // e.g. 200
        StatusCode          int
        Proto               string
        ProtoMajor          int
        ProtoMinor          int
        Header              header
        Body                io.ReadCloser
        ContentLength       int64
        TransfferEncoding   []string
        Close               bool
        Uncompressed        bool
        Trailer             Header
        Request             *Request
        TLS                 *tls.ConnectionState
    }

####  `net/http.Response.Body`

    type Response struct {
        Body io.ReadCloser
    }

#### `net/http.ResponseWriter`

    type ResposneWriter interface {
        // Header returns the header map that will be sent by WriteHeader.
        Header() Header

        // Write writes the data to the connection as part of an HTTP reply.
        Write([]byte) (int, error)

        // WriteHeader sends an HTTP response header with the provided status
        // code.
        WriteHeader(statusCode int)
    }
        A ResponseWriter interface is used by an HTTP handler to construct an
        HTTP response.

        A ResponseWriter may not be used after the Handler.ServeHTTP method has
        returned.

### `net/url`

#### `net/url.QueryEscape`

    func QueryEscape(s string) string
        QueryEscape escapes the string so it can be safely placed inside a URL
        query.

#### `net/url.URL`

    type URL struct {
        Scheme      string
        Opaque      string
        User        *Userinfo
        Host        string

        // path (relative paths may omit leading slash)
        Path        string
        RawPath     string
        ForceQuery  bool
        RawQuery    string
        Fragment    string
    }
        A URL represents a parsed URL (technically, a URI reference).

        The general form represented is:

        [scheme:][//[userinfo@host][/]path[?query][#fragment]

        URLs that do not start with a slash after the scheme are interpreted
        as:

        scheme:opaque[?query][#fragment]

#### `net/url.URL.Parse`

    func (u *URL) Parse(ref string) (*URL, error)
        Parse parses a URL in the context of the receiver. The provided URL may
        be relative or absolute. Parse returns nil, err on parse failure,
        otherwise its return value is the same as ResolveReference.

## `os`

### `os.Args`

    var Args []string
        Args hold the command-line arguments, starting with the program name.

    for i, a := range os.Args[1:] {
        fmt.Printf("Argument %d is: %s\n", i, a)
    }

### `os.Exit`

    func Exit(code int)
        Exit causes the current program to exit with the given status code.
        Conventionally, code zero indicates success, non-zero an error. The
        program terminates immediately; deferred functions are not run.

### `os.Open`

    func Open(name string) (*File, error)
        Open opens the named file for reading. If successful, methods on the
        returned file can be used for reading; the associated file descriptor
        has mode O_RDONLY. If there is an error, it will be of type *PathError.

Example:

    f, err := os.Open('foo.txt')
    if err != nil {
        // read from f
        f.Close()
    }


### `os.File`

    type File struct { }
        File represents an open file descriptor.

#### `os.File.Close`

    func (f *File) Close() error
        Close closes the File, rendering it unusable for I/O. It returns an
        error, if any.

Example:

    f, err := os.Open('foo.txt')
    if err != nil {
        // read from f
        f.Close()
    }

### `os.Stdin`, `os.Stdout` and `os.Stderr`

    var (
        Stdin  = NewFile(uintptr(syscall.Stdin), "/dev/stdin")
        Stdout = NewFile(uintptr(syscall.Stdout), "/dev/stdout")
        Stderr = NewFile(uintptr(syscall.Stderr), "/dev/stderr")
    )
        Stdin, Stdout, and Stderr are open Files pointing to the standard
        input, standard output, and standard error file descriptors.

        Note that the Go runtime writes to standard error for panics and
        crashes: closing Stderr may cause those messages to go elsewhere,
        perhapts to a file opened later.

Example:

    input := bufio.NewScanner(os.Stdin)
    for input.Scan() {
        fmt.Println(input.Text() + "\n")
    }

    fmt.Fprintln(os.Stdout, "this is a message")
    fmt.Fprintln(os.Stderr, "this is an error")

## `path`

    Package path implements utility routines for manipulating slash-separated
    paths.

## `path.base`

    func Base(path string) string
        Base returns the last element of path. trailing slashes are removed
        before extracting the last element. If the path is empty, Base returns
        ".". If the path consists entirely of slashes, Base returns "/".

### `path/filepath`

    Package filepath implements utility routines for manipulating filename
    paths in a way compatible with the target operating system-defined file
    paths.

## `regexp`

    Package regexp implements regular expressions search.

### `regexp.MustCompile`

    func MustCompile(str string) *Regexp
        MustCompile is like Compile but panics if the expression cannot be
        parsed. It simplifies safe initialization of global variables holding
        compiled regular expressions.

## `runtime`

    Package runtime contains operations that interact with Go's runtime system,
    such as functions to control goroutines. It also includes the low-level
    type information used by the reflect package; see reflect's documentation
    for the programmable interface to the run-time type system.

### `runtime.Stack`

    func Stack(buf []byte, all bool) int
        Stack formats a stack trace of the calling goroutine into buf and
        returns the number of bytes written to buf. If all is true, Stack
        formats stack traces of all other goroutines into buf after the trace
        for the current goroutine.

## `sort`

    Package sort provides primitives for sorting slices and user-defined
    collections.

### `sort.Strings`

    func Strings(a []string)
        Strings sorts a slice of strings in increasing order.

## `strconv`

### `strconv.Atoi`

    func Atoi(s string) (int, error)
        Atoi returns the result of ParseInt(s, 10, 0) converted to type int.

### `strconv.Itoa`

    func Itoa(i int) string
        Itoa is shorthand for FormatInt(int64(i), 10)

### `strconv.ParseInt`

    func ParseInt(s string, base int, bitSize int) (i int64, err error)
        ParseInt interprets a string s in the given base (0, 2 to 26) and bit
        size (0 to 64) and returns the corresponding value i.

## `strings`

### `strings.Contains`

    func Contains(s, substr string) bool
        Contains reports whether substr is within s.

### `strings.Count`

    func Count(s, substr string) int
        Count counts the number of non-overlapping instances of substr in s. If
        substr is an empty string, Count returns 1 + the number of Unicode code
        points in s.

### `strings.Fields`

    func Fields(s string) []string
        Fields splits the string s around each instance of one or more
        consecutive white space characters, as defined by unicode.IsSpace,
        returning a slice of substrings of s or an empty slice if s contains
        only white space.

### `strings.HasPrefix`

    func HasPrefix(s, prefix string) bool
        HasPrefix tests whether the string s begins with prefix.

### `strings.Index`

    func Index(s, substr string) int
        Index returns the index of the first instance of substr in s, or -1 if
        substr is not present in s.

### `strings.Join`

    func Join(a []string, sep string) string
        Join concatenates the elements of a to create a single string. The
        separator string sep is placed between elements in the resulting
        string.

Example:

    tokens := []string{"this", "is", "a", "test"}
    text := strings.Join(tokens, " ") // text == "this is a test"

### `strings.LastIndex`

    func LastIndex(s, substr string) int
        LastIndex returns the index of the last instance of substr in s, or -1
        if substr is not present in s.

### `strings.Split`

    func Split(s, sep string) []string
        Split slices s into all substrings separated by sep and returns a slice
        of the substrings between those separators.

        If s does not contain sep and sep is not empty, Split returns a slice
        of length 1 whose only element is s.

        If sep is empty, Split splits after each UTF-8 sequence. If both s and
        sep are empty, Split returns an empty slice.

        It is equivalent to SplitN with a count of -1.

Example:

    text := "this;is;a;test"
    tokens := strings.Split(text, ";")

## `sync`

### `sync.Mutex`

    type Mutex struct { }
        A Mutex is a mutual exclusion lock. The zero value for a Mutex is an
        unlocked mutex.

        A Mutex must not be copied after first use.

#### `sync.Mutex.Lock`

    func (m *Mutex) Lock()
        Lock locks m. If the lock is already in use, the calling goroutine
        blocks until the mutex is available.

#### `sync.Mutex.Unlock`

    func (m *Mutex) Unlock()
        Unlock unlocks m. It is a run-time error if m is not locked on entry to
        Unlock.

        A locked Mutex is not associated with a particular goroutine. It is
        allowed for one goroutine to lock a Mutex and then arrange for another
        goroutine to unlock it.

## `template`

    Package template implements data-driven templates for generating textual
    output.

    To generate HTML output, see package html/template, which has the same
    interface as this package but automatically secures HTML output against
    certain attacks.

    Templates are executed by applying them to a data structure. Annotations in
    the template refer to elements of the data structure (typically a field of
    a struct or a key in a map) to control execution and derive values to be
    displayed. Execution of the template walks the structure and sets the
    cursor, represented by a period '.' and called "dot", to the value at the
    current location in the structure as execution proceeds.

### `template.FuncMap`

    type FuncMap map[string]interface{}
        FuncMap is the type of the map defining the mapping from names to
        functions. Each function must have eeither a single return value, or
        two return values of which the second has type error. In that case, if
        the second (error) return value evaluates to non-nil during execution,
        execution terminates and Execute returns that error.

### `template.HTML`

    type HTML string
        HTML encapsulates a known safe HTML document fragment. It should not be
        used for HTML from a third-party, or HTML with unclosed tags or
        comments. The outputs of a sound HTML sanitizer and a template escaped
        by this package are fine for use with HTML.

        Use of this type presents a security risk: the encapsulated content
        should come from a trusted source, as it will be included verbatim in
        the template output.

### `template.Must`

    func Must(t *Template, err error) *Template
        Must is a helper that wraps a call to a function returning (*Template,
        error) and panics if the error is non-nil. It is intended for use in
        variable initializations such as

        var t  = template.Must(template.New("name").Parse("text"))

### `template.New`

    func New(name string) *Template
        New allocates a new, undefined template with the given name.

### `template.Template`

    type Template struct { }
        Template is the representation of a parsed template. The *parse.Tree
        field is exported only for use by html/template and should be treated
        as unexported by all other clients.

#### `template.Template.Execute`

    func (t *Template) Execute(wr io.Writer, data interface{}) error
        Execute applies a parsed template to the specified data object, and
        writes the output to wr. If an error occurs executing the template or
        writing its output, execution stops, but partial results may already
        have been written to the output writer. A template may be executed
        safely in parallel, although if parallel executions share a Writer the
        output may be interleaved.

        If data is a reflect.Value, the template applies to the concrete value
        that the reflect.Value holds, as in fmt.Print.


#### `template.Template.Funcs`

    func (t *Template) Funcs(funcMap FuncMap) *Template
        Funcs adds the elements of the argumentmap to the template's function
        map. It must be called before the template is parsed. It panics if a
        value in the map is not a function with appropriate return type or if
        the name cannot be used syntactically as a function in a template. It
        is legal to overwrite elements of the map. The return value is the
        template, so calls can be chained.

#### `template.Template.Parse`

    func (t *Template) Parse(text string) (*Template, error)
        Parse parses text as a template body for t. Named template definitions
        ({{define ...}} or {{block ...}} statements) in text define additional
        templates associated with t and are removed from the definition of t
        itself.

        Templates can be redefined in successive calls to Parse. A template
        definition with a body containing only white space and comments is
        considered empty and will not replace an existing template's body. This
        allows using Parse to add new named template definitions without
        overwriting the main template body.

## `time`

    Package time provides functionality for measuring and displaying time.

    The calendrical calculations always assume a Gregorian calendar, with no
    leap seconds.

### `time.Duration`

    type Duration int64
        A Duration represents the elapsed time between two instants as an int64
        nanosecond count. The representation limits the largest representable
        duration to approximately 290 years.

### `time.Now`

    func Now() Time
        Now returns the current local time.

### `time.Seconds`

    func (d Duration) Seconds() float64
        Seconds returns the duration as a floating point number of seconds.

### `time.Since`

    func Since(t Time) Duration
        Since returns the time elapsed since t. It is shorthand for
        time.Now().Sub(t).

### `time.Time`

    type Time struct {}
        A time represents an instant in time with nanosecond precision.

        Programs using times should typically store and pass them as values,
        not as pointers. That is, time variables and struct fields should be of
        type time.Time, not *time.Time.

        A Time value can be used by multiple goroutines simultaneously except
        that the methods GobDecode, UnmarshalBinary, UnmarshalJSON and
        UnmarshalText are not concurrency-safe.

        Time instants can be compared using the Before, After and Equal
        methods. The Sub method subtracts two intants, producing a Duration.
        The Add method adds a Time and a Duration, producing a Time.

        The zero value of type Time is January 1, year 1, 00:00:00.000000000
        UTC. As this time is unlikely to come up in practice, the IsZero method
        gives a simple way of detecting a time that has not been initialized
        explicitly.

        Each Time has associated with it a Location, consulted when computing
        the presentation form of the time, such as in the Format, Hour, and
        Year methods. The methods Local, UTC, and In return a Time with a
        specific location. Changing the location in this way changes only the
        presentation; it does not change the instant in time being denoted and
        therefore does not affect the computations described in earlier
        paragraphs.

        In addition to the requireed "wall clock" readig, a Time may contain an
        optional reading of the current process's monotonic clock, to provide
        additional precision for comparison or subtraction. See the "Monotonic
        Clocks" section in the package documentation for details.

        Note that the Go == operator compares not just the time instant but
        also the Location and the monotonic clock reading. Therefore, Time
        values should not be used as map or database keys without first
        guaranteeing that the identical Location has been set for all values,
        which can be achieved through the UTC or Local method, and that the
        monotonic clock reading has been stripped by setting t = t.Round(0). In
        general, prefer t.Equal(u) to t == u, since t.Equal uses the most
        accurate comparison available and correctly handles the case when only
        one of its arguments has a monotonic clock reading.

## `unicode`

    Package unicode provides data and functions to test some properties of
    Unicode code points.

### `unicode.ReplacementChar`

    const ReplacementChar = '\uFFFD' // Represents invalid code points.

### `unicode/utf8`

    Package utf8 implements functions and constants to support text encoded in
    UTF-8. It includes functions to translate between runes and UTF-8 byte
    sequences.

#### `unicode/utf8.DecodeRune`

    func DecodeRune(p []byte) (r rune, size int)
        DecodeRune unpacks the first UTF-8 encoding in p and returns the rune
        and its width in bytes.

#### `unicode/utf8.DecodeRuneInString`

    func DecodeRuneInString(s string) (r rune, size int)
        DecodeRuneInString is like DecodeRune but its input is a string.

#### `unicode/utf8.UTFMax`

    // maximum number of bytes of a UTF-8 encoded Unicode character.
    const UTFMax = 4

#### `unicode/utf8.RuneCount`

    func RuneCount(p []byte) int
        RuneCount returns the number of runes in p.

#### `unicode/utf8.RuneCountInString`

    func RuneCountInString(s string) (n int)
        RuneCountInString is like RuneCount but its input is a string.

## `x/net/html`

    Package html implements an HTML5-compliant tokenizer and parser.

### `x/net/html.Node`

    type Node struct {
        Parent, FirstChild, LastChild, PrevSibling, NextSibling *Node
        Type    NodeType
        Data    string
        Attr    []Attribute
        // more
    }
        A Node consists of a NodeType and some Data (tag name for element
        nodes, content for text) and are part of a tree of Nodes. Element nodes
        may also have a Namespace and contain a slice of Attributes. Data is
        unescaped, so that it looks like "a<b" rather than "a&lt;b". For
        element nodes, DataAtom is the atom for Data, or zero if Data is not a
        known tag name.

### `x/net/html.Parse`

    func Parse(r io.Reader) (*Node, error)
        Parse returns the parse tree for the HTML from the given Reader. The
        input is assumed to be UTF-8 encoded.

