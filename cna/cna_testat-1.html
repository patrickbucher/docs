<h1>CNA: 1. Testatprüfung</h1>

<h2>Was muss ein Rechner können?</h2>

<p>Ein Rechner muss einen Algorithmus ausführen können, dazu braucht er:</p>

<ul>
<li>Steuerwerk: Befehle eines Programms der Reihe nach ausführen</li>
<li>Speicher: Zahlen speichern</li>
<li>Rechenwerk: Speicherinhalt als Zahl interpretieren und manipulieren (rechnen)</li>
<li>Ablaufsteuerung: auf Inhalts des Speichers reagieren</li>
</ul>

<h2>Was besagt das Mooresche Gesetz?</h2>

<ul>
<li>Die Anzahl der Transistoren pro Fläche verdoppelt sich alle 18 Monate.</li>
<li>Die Anzahl der Transistoren pro Fläche steigt um 60% pro Jahr.</li>
</ul>

<h2>Welche speziellen Arten von Prozessoren gibt es?</h2>

<ul>
<li>Mikrocontroller: Mikroprozessor, Peripheriefunktionen und Speicher auf einem Chip (SoC: System on a Chip)</li>
<li>DSP: Digitaler Signalprozessor, bearbeitet digitale Signale, z.B. Audio- oder Videosignale</li>
<li>GPU: Graphics Processing Unit, für rechenintensive 2D- und 3D-Aufgaben</li>
<li>Krypto-Prozessoren: Ver- und entschlüsselt Daten, liegt zwischen CPU und Memory</li>
<li>Mathematischer Koprozessor, z.B. FPU (Floating Point Unit); heute auf der CPU</li>
</ul>

<h2>Was ist der Unterschied zwischen SRAM und DRAM?</h2>

<ul>
<li>SRAM: statisches RAM, benötigt 6 Transistoren pro Speicherzelle (Flip-Flop), behält seinen Wert</li>
<li>DRAM: dynaisches RAM, benötigt 1 Transistor pro Speicherzelle, muss aufgefrischt werden</li>
<li>PSRAM: DRAM mit eingebauter Auffrischung</li>
</ul>

<h2>Wie sieht die Speicherhierarchie aus?</h2>

<ol>
<li>Register (SRAM)</li>
<li>Cache (SRAM)</li>
<li>Arbeitsspeicher (DRAM)</li>
<li>Dateisystem (SSD, HD)</li>
<li>Archiv (HD, optische Medien, Magnetbänder)</li>
</ol>

<h2>Wie funktioniert der Fetch/Decode/Execute-Cycle?</h2>

<ol>
<li>Fetch: den nächsten Befehl ins Befehlsregister laden; Programmzähler erhöhen</li>
<li>Decode: den Befehl dekodieren; ermitteln, welcher Befehl auszuführen ist; zusätzliche Datenwörter aus dem Speicher laden, falls der Befehl diese benötigt</li>
<li>Execute: den Befehl ausführen; das Ergebnis im Speicher abspeichern; weiter bei 1.</li>
</ol>

<h2>Woraus besteht eine Von-Neumann-Maschine?</h2>

<ol>
<li>Rechenwerk</li>
<li>Steuerwerk</li>
<li>Speicher</li>
<li>Ein- und Ausgabe</li>
</ol>

<h2>Wie können negative Zahlen dargestellt werden?</h2>

<ol>
<li>Vorzeichenbehafteter Wert: erstes Bit 0 für positive, 1 für negative Zahlen</li>
<li>1er-Komplement: alle Bits umkehren</li>
<li>2er-Komplement: alle Bits umkehren, eins hinzuaddieren</li>
<li>Exzesscode: Versatz um +n</li>
</ol>

<h2>Welche Gleitkommazahlen gibt es nach IEEE 754?</h2>

<ul>
<li>einfache Genauigkeit: 32 Bits (1 Vorzeichen, 8 Exponent, 23 Mantisse)</li>
<li>doppelte Genauigkeit: 64 Bits (1 Vorzeichen, 11 Exponent, 52 Mantisse)</li>
</ul>

<h2>Wie wird eine Fliesskommazahl in IEEE 754 dargestellt?</h2>

<ol>
<li>Vorzeichen ermitteln, 1 für negative, 0 für positive Zahl</li>
<li>die Zahl durch Multiplikation bzw. Division mit 2^n in das Intervall [1;2[ bringen (normalisieren)</li>
<li>den (positiven oder negativen!) Exponenten n mit Excess127 normalisieren (127 addieren)</li>
<li>von der normalisierten Zahl 1 abziehen (redundant, da immer eine 1 vorne steht)</li>
<li>die Mantisse aus der Summe von 1/2+1/4+...+1/2^n darstellen und bei den entsprechenden Stellen die Bits auf 1 setzen</li>
<li>Vorzeichen, Exponent und Mantisse binär auflisten</li>
<li>die Binärzahlen zu je 4 Bits gruppieren</li>
<li>die einzelnen Gruppen als hexadezimale Zahl darstellen</li>
</ol>

<h2>Wie ermittelt man eine Fliesskommazahl anzand der IEEE-754-Darstellung?</h2>

<ol>
<li>jede Ziffer der hexadezimalen Zahl mit vier Bits im Binärcode darstellen</li>
<li>die Bitreihe aufteilen
<ol>
<li>Erstes Bit: Vorzeichen</li>
<li>die nächsten 8 (single) bzw. 11 (double) Bits: Exponent</li>
<li>die letzten 23 (single) bzw. 52 (double) Bits: Mantisse</li>
</ol></li>
<li>die Mantisse aufsummieren
<ol>
<li>Erstes Bit = 1/2</li>
<li>Zweites Bit = 1/4</li>
<li>n-tes Bit = 1/2^n</li>
</ol></li>
<li>die Mantisse mit 1 addieren (bei der Konvertierung weggelassen, da redundant)</li>
<li>den Exponent bestimmen und 127 davon subtrahieren (Excess127)</li>
<li>den Wert ausrechnen
<ol>
<li>Mantisse * 2^Exponent</li>
<li>Vorzeichen nicht vergessen</li>
</ol></li>
</ol>

<h2>Mit welcher Schaltung lassen sich AND, OR und NOT realisieren?</h2>

<ul>
<li>AND: zwei serielle Schalter</li>
<li>OR: zwei parallele Schalter</li>
<li>NOT: ein Öffner</li>
</ul>

<h2>Wie lauten die DeMorganschen Gesetze?</h2>

<ol>
<li>!(A || B) == !A &amp;&amp; !B</li>
<li>!(A &amp;&amp; B) == !A || !B</li>
</ol>

<h2>Wodurch zeichnet sich die Harvard-Architektur aus?</h2>

<ul>
<li>Separate Speicher für Daten und Befehle</li>
<li>Separate Busse zu den beiden Speichern</li>
<li>Vorteil gegenüber Von-Neumann-Architektur
<ol>
<li>Befehle und D1.en können gleichzeitig gel1.en werden: Geschwindigkeit</li>
<li>Strikte Trennung von D1.en und Progr1.men: Sicherheit</li>
<li>D1.enwortbreite und Befehlswortbreite sind un1.hängig vonein1.der</li>
<li>Synchrones L1.en 1.ch mehrerer Rechenwerke</li>
</ol></li>
</ul>

<p>In der Praxis sind oft Mischformen von Harvard- und Von-Neumann-Rechnern zu finden.</p>

<h2>Welche Benchmarkprogramme gibt es?</h2>

<ul>
<li>Linpack: Lineare Gleichungssysteme</li>
<li>SPEC: Standard PErformance Evaluation</li>
<li>Whetstone: Floating-Point- und Integer-Berechnungen</li>
<li>Dhrystone: Integer-Berechnungen</li>
<li>Weitere für PC: 3DMark, Windows-Leistungsindex, Geekbench</li>
</ul>

<h2>In welchen Einheiten wird Computerperformance gemessen?</h2>

<ul>
<li>MIPS: Million Instructions per Second (unspezifisch)</li>
<li>Flops (MegaFlops, GigaFlops): Floating Point Operations per Second</li>
<li>Laufzeit spezifischer Programme/Rechenaufgaben</li>
</ul>

<h2>Wie lauten die wichtigsten Kennwerte der aktuell leistungsstärksten Computer (Stand 2016)?</h2>

<ul>
<li>ca. 10 Millionen Cores</li>
<li>ca. 100 Petaflops (100 * 10^15 Flops)</li>
<li>ca. 15 Megawatt Leistung</li>
</ul>

<h2>Was bedeutet Endian?</h2>

<ul>
<li>In welcher Reihenfolge die Ziffern einer Grösse aufgelistet werden
<ul>
<li>Big Endian: grosse zuerst
<ul>
<li>Datumsangabe 2016/10/19 (19. Oktober 2016)</li>
<li>Zahlen in Englisch: 122 one hundred twenty to</li>
</ul></li>
<li>Little Endian: kleine zuerst
<ul>
<li>Datumsangabe 19.10.2016 (auch 19. Oktober 2016)</li>
<li>Zweistellige Zahlen in Deutsch: 22 zweiundzwanzig</li>
</ul></li>
</ul></li>
<li>In der Informatik bezeichnet Endian die Byte-Reihenfolge im Arbeitsspeicher.
<ul>
<li>Big Endian
<ul>
<li>UNIX</li>
<li>Java</li>
<li>Motorola</li>
<li>Freescale</li>
</ul></li>
<li>Little Endian
<ul>
<li>Windows</li>
<li>Intel</li>
</ul></li>
</ul></li>
</ul>

<h2>Welche Levels/Stufen gibt es bei den Rechnerarchitekturen?</h2>

<ul>
<li>Level 5: Problem-oriented language level
<ul>
<li>Translation (compiler)</li>
</ul></li>
<li>Level 4: Assembly language lavel
<ul>
<li>Translation (assembler)</li>
</ul></li>
<li>Level 3: Operating system machine level
<ul>
<li>Partial interpretation (operating system)</li>
</ul></li>
<li>Level 2: Instruction set architecture level
<ul>
<li>Interpretation (microprogram) or direct execution</li>
</ul></li>
<li>Level 1: Microarchitecture level
<ul>
<li>Hardware</li>
</ul></li>
<li>Level 0: Digital logic level</li>
</ul>

<h2>Welche Operationsarten gibt es?</h2>

<ol>
<li>Datentransfer-Operationen</li>
<li>Arithmetische und logische Operationen</li>
<li>Programmablaufsteuerung</li>
</ol>

<h2>Welche Informationen enthält ein Befehl?</h2>

<ul>
<li>durchzuführende Operation</li>
<li>0, 1 oder n Operanden: Typ, Länge Adressierungsart und Adressen von:
<ul>
<li>erstem Quellenoperand</li>
<li>zweitem Quellenoperand</li>
<li>Resultat</li>
</ul></li>
<li>Adresse des nächsten Befehls
<ul>
<li>implizit (durch Befehlslänge)</li>
<li>explizit (durch bedingen Sprung)</li>
</ul></li>
</ul>

<h2>Welche Adressierungsarten gibt es?</h2>

<ul>
<li>Absolute oder direkte Adressierung: absolute Adresse
<ul>
<li>LDA $0832 (lade den Wert aus Speicherzelle 832)</li>
</ul></li>
<li>Registeradressierung: Name des Registers
<ul>
<li>LDA R1 (lade den Wert aus dem Register 1)</li>
</ul></li>
<li>Unmittelbare Adressierung: Wertangabe
<ul>
<li>LDA #13 (lade den Wert 13)</li>
</ul></li>
<li>Indirekte Adressierung
<ul>
<li>LDA (IX): lade den Wert aus dem Register, dessen Adresse unter "IX" zu finden ist</li>
</ul></li>
<li>Indizierte Adressierung: absolute Adressierung mit Versatz
<ul>
<li>LDA $0832, 5 (lade den Wert fünf Speicherzellen nach der Adresse 832)</li>
</ul></li>
</ul>

<h2>Welche Arten von Befehlen gibt es?</h2>

<ul>
<li>Einadressbefehle
<ul>
<li>INC $001: Erhöhe den Wert auf der Speicherzelle 1 um 1</li>
</ul></li>
<li>Zweiadressbefehle
<ul>
<li>ADD $001, $002: Addiere die Werte auf den Speicherzellen 1 und 2 und schreibe das Ergebnis auf die Speicherzelle 1 (oder 2)</li>
</ul></li>
<li>Dreiadressbefehle
<ul>
<li>ADD $001, $002, $003: Addiere die Werte auf den Speicherzellen 1 und 2 und schreibe das Ergebnis auf die Speicherzelle 3</li>
</ul></li>
</ul>

<h2>Was macht und woraus besteht ein Steuerwerk?</h2>

<p>Das Steuerwerk steuert den Ablauf der Befehlsabarbeitung. Es verfügt über:</p>

<ul>
<li>einen Program Counter, der auf die nächste Instruktion zeigt</li>
<li>einen Instruktionsregister</li>
<li>einen Adressregister</li>
<li>einen Stackpointer</li>
</ul>

<h2>Wie funktioniert ein Stack?</h2>

<ul>
<li>Der Stack ist ein Stapelspeicher, die Daten werden darauf "gestapelt".</li>
<li>Es kann nur immer auf das zuoberst gespeicherte Datenelement zugegriffen werden.</li>
<li>FIFO: first in, first out</li>
<li>LILO: last in, last out</li>
<li>Der Stack Pointer (Stapelzeiger) zeigt immer auf den obersten Eintrag</li>
<li>Befehle
<ul>
<li>push: Daten auf den Stack schreiben (obendrauf legen)</li>
<li>pop: Daten vom Stack auslesen (wegnehmen)</li>
</ul></li>
</ul>

<h2>Wozu wird ein Stack gebraucht?</h2>

<ul>
<li>Zur Ausführung von Unterprogrammen
<ul>
<li>Parameterübergabe</li>
<li>Speicherung der Rücksprungadresse</li>
<li>Ablage des Rückgabewertes</li>
</ul></li>
<li>Als Zwischenspeicher</li>
<li>Zur Interrupt-Behandlung</li>
</ul>

<h2>Was versteht man unter dem Semantic Gap?</h2>

<ul>
<li>Die Kluft zwischen verschiedenen Sprachen (der Unterschied ihrer Ausdrucksstärken)
<ul>
<li>natürliche Sprache: "die Zahl x um drei Erhöhen und um zwei reduzieren"</li>
<li>mathematische Notation: x + 3 - 2</li>
<li>Programmiersprache (Java): x = x + 3 - 2;</li>
<li>Maschinensprache
<ul>
<li>ADD &amp;x, 3</li>
<li>SUB &amp;x, 2</li>
</ul></li>
</ul></li>
<li>Hochsprachen wie Java versuchen den Semantic Gap zu schliessen.</li>
</ul>

<h2>Wie lauten die in der Informatik gebräuchlichsten SI-Vorsätze?</h2>

<ul>
<li>kleiner als 1
<ul>
<li>10^-3: milli, m</li>
<li>10^-6: micro, µ</li>
<li>10^-9: nano, n</li>
</ul></li>
<li>grösser als 1
<ul>
<li>10^3: kilo, k</li>
<li>10^6: mega, M</li>
<li>10^9: giga, G</li>
<li>10^12: tera, T</li>
<li>10^15: peta, P</li>
<li>10^18: exa, E</li>
</ul></li>
</ul>

<h2>Was ist ein PC-Chipsatz?</h2>

<ul>
<li>Er unterstützt den Prozessor bei seinen Aufgaben.</li>
<li>Er realisiert die elektrischen Anschlüsse (Pins, Schnittstellen)</li>
<li>Er besteht aus:
<ul>
<li>North-Bridge/MCH (Memory Controller Hub): Steuert Datenfluss zwischen CPU, Speicher und South-Bridge</li>
<li>South-Bridge/ICH (I/O Controller Hub): Steuert Datenfluss zwischen Peripherie, PCI-Bus, Festplatten und externen Schnittstellen und der North-Bridge</li>
</ul></li>
</ul>

<h2>Welche RAM-Busse gibt es?</h2>

<ul>
<li>SDRAM: synchrones DRAM</li>
<li>DDR RAM: double data rate
<ul>
<li>DDR II RAM: vierfach Fetch</li>
<li>DDR III RAM: achtfach Fetch</li>
</ul></li>
</ul>

<h2>Welche RAM-Modul-Bauformen gibt es?</h2>

<ul>
<li>SIMM: Single Inline Memory Module (ältere RAM-Bausteine)</li>
<li>DIMM: Dual Inline Memory Module (modernere RAM-Bausteine für PC)</li>
<li>SO-DIMM: Small Outline DIMM (für Laptops)</li>
</ul>

<h2>Was sind die Vorteile von RAID?</h2>

<ul>
<li>Redundante Abspeicherung: ermöglicht Datenrettung im Falle kaputter Festplatten</li>
<li>Ausfallsicherheit: das System läuft weiter im Falle einer kaputten Festplatte</li>
<li>Realisierung extrem grosser virtueller Laufwerke aus mehreren Festplatten</li>
<li>Fehlererkennung</li>
</ul>
