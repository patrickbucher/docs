<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h1 id="cna-1.-testatprüfung">CNA: 1. Testatprüfung</h1>
<h2 id="was-muss-ein-rechner-können">Was muss ein Rechner können?</h2>
<p>Ein Rechner muss einen Algorithmus ausführen können, dazu braucht er:</p>
<ul>
<li>Steuerwerk: Befehle eines Programms der Reihe nach ausführen</li>
<li>Speicher: Zahlen speichern</li>
<li>Rechenwerk: Speicherinhalt als Zahl interpretieren und manipulieren (rechnen)</li>
<li>Ablaufsteuerung: auf Inhalt des Speichers reagieren</li>
</ul>
<h2 id="was-beschreibt-eine-rechenarchitektur">Was beschreibt eine Rechenarchitektur?</h2>
<p>Die Art und Weise wie ein Rechner aus Baulementen aufgebaut ist.</p>
<h2 id="kann-auf-einem-turing-rechner-windows-7-ausgeführt-werden">Kann auf einem Turing Rechner Windows 7 ausgeführt werden?</h2>
<p>Theoretisch ja, da alle Computer gleich sind und jede Architektur emuliert werden kann.</p>
<h2 id="was-besagt-das-mooresche-gesetz">Was besagt das Mooresche Gesetz?</h2>
<ul>
<li>Die Anzahl der Transistoren pro Fläche verdoppelt sich alle 18 Monate.</li>
<li>Die Anzahl der Transistoren pro Fläche steigt um 60% pro Jahr.</li>
</ul>
<h2 id="was-ist-ein-mikroprozessor">Was ist ein Mikroprozessor?</h2>
<p>Es werden alle Grundfunktionen (Rechenwerk, Steuerwerk, ...) auf einem einzelnen Mikrochip vereint.</p>
<h2 id="welche-speziellen-arten-von-prozessoren-gibt-es">Welche speziellen Arten von Prozessoren gibt es?</h2>
<ul>
<li>Mikrocontroller: Mikroprozessor, Peripheriefunktionen und Speicher auf einem Chip (SoC: System on a Chip)</li>
<li>DSP: Digitaler Signalprozessor, bearbeitet digitale Signale, z.B. Audio- oder Videosignale</li>
<li>GPU: Graphics Processing Unit, für rechenintensive 2D- und 3D-Aufgaben</li>
<li>Krypto-Prozessoren: ver- und entschlüsselt Daten, liegt zwischen CPU und Memory</li>
<li>Mathematischer Koprozessor, z.B. FPU (Floating Point Unit); heute auf der CPU</li>
</ul>
<h2 id="was-ist-der-unterschied-zwischen-sram-und-dram">Was ist der Unterschied zwischen SRAM und DRAM?</h2>
<ul>
<li>SRAM: statisches RAM, benötigt 6 Transistoren pro Speicherzelle (Flip-Flop), behält seinen Wert</li>
<li>DRAM: dynaisches RAM, benötigt 1 Transistor pro Speicherzelle, muss aufgefrischt werden</li>
<li>PSRAM: DRAM mit eingebauter Auffrischung</li>
</ul>
<h2 id="wie-sieht-die-speicherhierarchie-aus">Wie sieht die Speicherhierarchie aus?</h2>
<table>
<thead>
<tr class="header">
<th>#</th>
<th>Name</th>
<th>Typ</th>
<th>Geschwindigkeit</th>
<th>Speichergrösse</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Register</td>
<td>SRAM</td>
<td>0.2-1ns</td>
<td>kByte</td>
</tr>
<tr class="even">
<td>2</td>
<td>Cache</td>
<td>SRAM</td>
<td>2ns</td>
<td>0.5-8MB</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Arbeitsspeicher</td>
<td>DRAM</td>
<td>5-10ns</td>
<td>1-32 GB</td>
</tr>
<tr class="even">
<td>4</td>
<td>Dateisystem</td>
<td>SSD, HD</td>
<td>3-10ms (SSD 30mums)</td>
<td>60GB-10TB</td>
</tr>
<tr class="odd">
<td>5</td>
<td>Archiv</td>
<td>optische Medien, Magnetbänder</td>
<td>1-110s (Optisch 100ms)</td>
<td>240GB-5TB</td>
</tr>
</tbody>
</table>
<h2 id="wie-funktioniert-der-fetchdecodeexecute-cycle">Wie funktioniert der Fetch/Decode/Execute-Cycle?</h2>
<ol style="list-style-type: decimal">
<li>Fetch: den nächsten Befehl ins Befehlsregister laden; Programmzähler erhöhen</li>
<li>Decode: den Befehl dekodieren; ermitteln, welcher Befehl auszuführen ist; zusätzliche Datenwörter aus dem Speicher laden, falls der Befehl diese benötigt</li>
<li>Execute: den Befehl ausführen; das Ergebnis im Speicher abspeichern; weiter bei 1.</li>
</ol>
<h2 id="woraus-besteht-eine-von-neumann-maschine">Woraus besteht eine Von-Neumann-Maschine?</h2>
<ol style="list-style-type: decimal">
<li>Rechenwerk</li>
<li>Steuerwerk</li>
<li>Speicher</li>
<li>Ein- und Ausgabe</li>
</ol>
<h2 id="wie-können-negative-zahlen-dargestellt-werden">Wie können negative Zahlen dargestellt werden?</h2>
<ol style="list-style-type: decimal">
<li>Vorzeichenbehafteter Wert: erstes Bit 0 für positive, 1 für negative Zahlen</li>
<li>1er-Komplement: alle Bits umkehren</li>
<li>2er-Komplement: alle Bits umkehren, eins hinzuaddieren</li>
<li>Exzesscode: Versatz um +n</li>
</ol>
<h2 id="welche-gleitkommazahlen-gibt-es-nach-ieee-754">Welche Gleitkommazahlen gibt es nach IEEE 754?</h2>
<ul>
<li>einfache Genauigkeit: 32 Bits (1 Vorzeichen, 8 Exponent, 23 Mantisse)</li>
<li>doppelte Genauigkeit: 64 Bits (1 Vorzeichen, 11 Exponent, 52 Mantisse)</li>
</ul>
<h2 id="wie-wird-eine-fliesskommazahl-in-ieee-754-dargestellt">Wie wird eine Fliesskommazahl in IEEE 754 dargestellt?</h2>
<ol style="list-style-type: decimal">
<li>Vorzeichen ermitteln, 1 für negative, 0 für positive Zahl</li>
<li>die Zahl durch Multiplikation bzw. Division mit 2^n in das Intervall [1;2[ bringen (normalisieren)</li>
<li>den (positiven oder negativen!) Exponenten n mit Excess127 normalisieren (127 addieren)</li>
<li>von der normalisierten Zahl 1 abziehen (redundant, da immer eine 1 vorne steht)</li>
<li>die Mantisse aus der Summe von 1/2+1/4+...+1/2^n darstellen und bei den entsprechenden Stellen die Bits auf 1 setzen</li>
<li>Vorzeichen, Exponent und Mantisse binär auflisten</li>
<li>die Binärzahlen zu je 4 Bits gruppieren</li>
<li>die einzelnen Gruppen als hexadezimale Zahl darstellen</li>
</ol>
<h2 id="wie-ermittelt-man-eine-fliesskommazahl-anhand-der-ieee-754-darstellung">Wie ermittelt man eine Fliesskommazahl anhand der IEEE-754-Darstellung?</h2>
<ol style="list-style-type: decimal">
<li>jede Ziffer der hexadezimalen Zahl mit vier Bits im Binärcode darstellen</li>
<li>die Bitreihe aufteilen
<ol style="list-style-type: decimal">
<li>Erstes Bit: Vorzeichen</li>
<li>die nächsten 8 (single) bzw. 11 (double) Bits: Exponent</li>
<li>die letzten 23 (single) bzw. 52 (double) Bits: Mantisse</li>
</ol></li>
<li>die Mantisse aufsummieren
<ol style="list-style-type: decimal">
<li>Erstes Bit = 1/2</li>
<li>Zweites Bit = 1/4</li>
<li>n-tes Bit = 1/2^n</li>
</ol></li>
<li>die Mantisse mit 1 addieren (bei der Konvertierung weggelassen, da redundant)</li>
<li>den Exponent bestimmen und 127 davon subtrahieren (Excess127)</li>
<li>den Wert ausrechnen
<ol style="list-style-type: decimal">
<li>Mantisse * 2^Exponent</li>
<li>Vorzeichen nicht vergessen</li>
</ol></li>
</ol>
<h2 id="mit-welcher-schaltung-lassen-sich-and-or-und-not-realisieren">Mit welcher Schaltung lassen sich AND, OR und NOT realisieren?</h2>
<ul>
<li>AND: zwei serielle Schalter</li>
<li>OR: zwei parallele Schalter</li>
<li>NOT: ein Öffner</li>
</ul>
<h2 id="wie-lauten-die-demorganschen-gesetze">Wie lauten die DeMorganschen Gesetze?</h2>
<ol style="list-style-type: decimal">
<li>!(A || B) == !A &amp;&amp; !B</li>
<li>!(A &amp;&amp; B) == !A || !B</li>
</ol>
<h2 id="wodurch-zeichnet-sich-die-harvard-architektur-aus">Wodurch zeichnet sich die Harvard-Architektur aus?</h2>
<ul>
<li>Separate Speicher für Daten und Befehle</li>
<li>Separate Busse zu den beiden Speichern</li>
<li>Vorteil gegenüber Von-Neumann-Architektur
<ol style="list-style-type: decimal">
<li>Befehle und Daten können gleichzeitig gelesen werden: Geschwindigkeit</li>
<li>Strikte Trennung von Daten und Programmen: Sicherheit</li>
<li>Datenwortbreite und Befehlswortbreite sind unabhängig voneinander</li>
<li>Synchrones Laden durch mehrerer Rechenwerke</li>
</ol></li>
</ul>
<p>In der Praxis sind oft Mischformen von Harvard- und Von-Neumann-Rechnern zu finden.</p>
<h2 id="welche-benchmarkprogramme-gibt-es">Welche Benchmarkprogramme gibt es?</h2>
<ul>
<li>Linpack: Lineare Gleichungssysteme</li>
<li>SPEC: Standard Performance Evaluation</li>
<li>Whetstone: Floating-Point- und Integer-Berechnungen</li>
<li>Dhrystone: Integer-Berechnungen</li>
<li>Weitere für PC: 3DMark, Windows-Leistungsindex, Geekbench</li>
</ul>
<h2 id="in-welchen-einheiten-wird-computerperformance-gemessen">In welchen Einheiten wird Computerperformance gemessen?</h2>
<ul>
<li>MIPS: Million Instructions per Second (unspezifisch)</li>
<li>Flops (MegaFlops, GigaFlops): Floating Point Operations per Second</li>
<li>Laufzeit spezifischer Programme/Rechenaufgaben</li>
</ul>
<h2 id="wie-lauten-die-wichtigsten-kennwerte-der-aktuell-leistungsstärksten-computer-stand-2016">Wie lauten die wichtigsten Kennwerte der aktuell leistungsstärksten Computer (Stand 2016)?</h2>
<ul>
<li>ca. 10 Millionen Cores</li>
<li>ca. 100 Petaflops (100 * 10^15 Flops)</li>
<li>ca. 15 Megawatt Leistung</li>
</ul>
<h2 id="was-bedeutet-endian">Was bedeutet Endian?</h2>
<ul>
<li>In welcher Reihenfolge die Ziffern einer Grösse aufgelistet werden
<ul>
<li>Big Endian: grosse zuerst
<ul>
<li>Datumsangabe 2016/10/19 (19. Oktober 2016)</li>
<li>Zahlen in Englisch: 122 one hundred twenty two</li>
</ul></li>
<li>Little Endian: kleine zuerst
<ul>
<li>Datumsangabe 19.10.2016 (auch 19. Oktober 2016)</li>
<li>Zweistellige Zahlen in Deutsch: 22 zweiundzwanzig</li>
</ul></li>
</ul></li>
<li>In der Informatik bezeichnet Endian die Byte-Reihenfolge im Arbeitsspeicher.
<ul>
<li>Big Endian: UNIX, Java, Motorola, Freescale</li>
<li>Little Endian: Windows, Intel</li>
</ul></li>
</ul>
<h2 id="welche-levelsstufen-gibt-es-bei-den-rechnerarchitekturen">Welche Levels/Stufen gibt es bei den Rechnerarchitekturen?</h2>
<ul>
<li>Level 5: Problem-oriented language level
<ul>
<li>Translation (compiler)</li>
</ul></li>
<li>Level 4: Assembly language level
<ul>
<li>Translation (assembler)</li>
</ul></li>
<li>Level 3: Operating system machine level
<ul>
<li>Partial interpretation (operating system)</li>
</ul></li>
<li>Level 2: Instruction set architecture level
<ul>
<li>Interpretation (microprogram) or direct execution</li>
</ul></li>
<li>Level 1: Microarchitecture level
<ul>
<li>Hardware</li>
</ul></li>
<li>Level 0: Digital logic level</li>
</ul>
<h2 id="welche-operationsarten-gibt-es">Welche Operationsarten gibt es?</h2>
<ol style="list-style-type: decimal">
<li>Datentransfer-Operationen</li>
<li>Arithmetische und logische Operationen</li>
<li>Programmablaufsteuerung</li>
</ol>
<h2 id="welche-informationen-enthält-ein-befehl">Welche Informationen enthält ein Befehl?</h2>
<ul>
<li>durchzuführende Operation</li>
<li>0, 1 oder n Operanden: Typ, Länge Adressierungsart und Adressen von:
<ul>
<li>erstem Quellenoperand</li>
<li>zweitem Quellenoperand</li>
<li>Resultat</li>
</ul></li>
<li>Adresse des nächsten Befehls
<ul>
<li>implizit (durch Befehlslänge)</li>
<li>explizit (durch bedingten Sprung)</li>
</ul></li>
</ul>
<h2 id="welche-adressierungsarten-gibt-es">Welche Adressierungsarten gibt es?</h2>
<ul>
<li>Absolute oder direkte Adressierung: absolute Adresse
<ul>
<li>LDA $0832 (lade den Wert aus Speicherzelle 832)</li>
</ul></li>
<li>Registeradressierung: Name des Registers
<ul>
<li>LDA R1 (lade den Wert aus dem Register 1)</li>
</ul></li>
<li>Unmittelbare Adressierung: Wertangabe
<ul>
<li>LDA #13 (lade den Wert 13)</li>
</ul></li>
<li>Indirekte Adressierung
<ul>
<li>LDA (IX): lade den Wert aus dem Register, dessen Adresse unter &quot;IX&quot; zu finden ist</li>
</ul></li>
<li>Indizierte Adressierung: absolute Adressierung mit Versatz
<ul>
<li>LDA $0832, 5 (lade den Wert fünf Speicherzellen nach der Adresse 832)</li>
</ul></li>
</ul>
<h2 id="welche-arten-von-befehlen-gibt-es">Welche Arten von Befehlen gibt es?</h2>
<ul>
<li>Einadressbefehle
<ul>
<li>INC $001: Erhöhe den Wert auf der Speicherzelle 1 um 1</li>
</ul></li>
<li>Zweiadressbefehle
<ul>
<li>ADD $001, $002: Addiere die Werte auf den Speicherzellen 1 und 2 und schreibe das Ergebnis auf die Speicherzelle 1 (oder 2)</li>
</ul></li>
<li>Dreiadressbefehle
<ul>
<li>ADD $001, $002, $003: Addiere die Werte auf den Speicherzellen 1 und 2 und schreibe das Ergebnis auf die Speicherzelle 3</li>
</ul></li>
</ul>
<h2 id="was-macht-und-woraus-besteht-ein-steuerwerk">Was macht und woraus besteht ein Steuerwerk?</h2>
<p>Das Steuerwerk steuert den Ablauf der Befehlsabarbeitung. Es verfügt über:</p>
<ul>
<li>einen Program Counter, der auf die nächste Instruktion zeigt</li>
<li>ein Instruktionsregister</li>
<li>ein Adressregister</li>
<li>einen Stackpointer</li>
</ul>
<h2 id="wie-funktioniert-ein-stack">Wie funktioniert ein Stack?</h2>
<ul>
<li>Der Stack ist ein Stapelspeicher, die Daten werden darauf &quot;gestapelt&quot;.</li>
<li>Es kann nur immer auf das zuoberst gespeicherte Datenelement zugegriffen werden.
<ul>
<li>LIFO: last in first out</li>
<li>FILO: first in last out</li>
</ul></li>
<li>Der Stack Pointer (Stapelzeiger) zeigt immer auf den obersten Eintrag</li>
<li>Befehle
<ul>
<li>push: Daten auf den Stack schreiben (obendrauf legen)</li>
<li>pop: Daten vom Stack auslesen (wegnehmen)</li>
</ul></li>
</ul>
<h2 id="wozu-wird-ein-stack-gebraucht">Wozu wird ein Stack gebraucht?</h2>
<ul>
<li>Zur Ausführung von Unterprogrammen
<ul>
<li>Parameterübergabe</li>
<li>Speicherung der Rücksprungadresse</li>
<li>Ablage des Rückgabewertes</li>
</ul></li>
<li>Als Zwischenspeicher</li>
<li>Zur Interrupt-Behandlung</li>
</ul>
<h2 id="was-versteht-man-unter-dem-semantic-gap">Was versteht man unter dem Semantic Gap?</h2>
<ul>
<li>Die Kluft zwischen verschiedenen Sprachen (der Unterschied ihrer Ausdrucksstärken)
<ul>
<li>natürliche Sprache: &quot;die Zahl x um drei Erhöhen und um zwei reduzieren&quot;</li>
<li>mathematische Notation: x + 3 - 2</li>
<li>Programmiersprache (Java): x = x + 3 - 2;</li>
<li>Maschinensprache
<ul>
<li>ADD &amp;x, 3</li>
<li>SUB &amp;x, 2</li>
</ul></li>
</ul></li>
<li>Hochsprachen wie Java versuchen den Semantic Gap zu schliessen.</li>
</ul>
<h2 id="wie-lauten-die-in-der-informatik-gebräuchlichsten-si-vorsätze">Wie lauten die in der Informatik gebräuchlichsten SI-Vorsätze?</h2>
<ul>
<li>kleiner als 1:
<ul>
<li>10^-3: milli, m</li>
<li>10^-6: micro, µ</li>
<li>10^-9: nano, n</li>
</ul></li>
<li>grösser als 1:
<ul>
<li>10^3: kilo, k</li>
<li>10^6: mega, M</li>
<li>10^9: giga, G</li>
<li>10^12: tera, T</li>
<li>10^15: peta, P</li>
<li>10^18: exa, E</li>
</ul></li>
</ul>
<h2 id="was-ist-ein-pc-chipsatz">Was ist ein PC-Chipsatz?</h2>
<ul>
<li>Er unterstützt den Prozessor bei seinen Aufgaben.</li>
<li>Er realisiert die elektrischen Anschlüsse (Pins, Schnittstellen)</li>
<li>Er besteht aus:
<ul>
<li>North-Bridge/MCH (Memory Controller Hub): Steuert Datenfluss zwischen CPU, Speicher und South-Bridge</li>
<li>South-Bridge/ICH (I/O Controller Hub): Steuert Datenfluss zwischen Peripherie, PCI-Bus, Festplatten und externen Schnittstellen und der North-Bridge</li>
</ul></li>
</ul>
<h2 id="welche-ram-busse-gibt-es">Welche RAM-Busse gibt es?</h2>
<ul>
<li>SDRAM: synchrones DRAM</li>
<li>DDR RAM: double data rate
<ul>
<li>DDR II RAM: vierfach Fetch</li>
<li>DDR III RAM: achtfach Fetch</li>
</ul></li>
</ul>
<h2 id="welche-ram-modul-bauformen-gibt-es">Welche RAM-Modul-Bauformen gibt es?</h2>
<ul>
<li>SIMM: Single Inline Memory Module (ältere RAM-Bausteine)</li>
<li>DIMM: Dual Inline Memory Module (modernere RAM-Bausteine für PC)</li>
<li>SO-DIMM: Small Outline DIMM (für Laptops)</li>
</ul>
<h2 id="was-sind-die-vorteile-von-raid">Was sind die Vorteile von RAID?</h2>
<ul>
<li>Redundante Abspeicherung: ermöglicht Datenrettung im Falle kaputter Festplatten</li>
<li>Ausfallsicherheit: das System läuft weiter im Falle einer kaputten Festplatte</li>
<li>Realisierung extrem grosser virtueller Laufwerke aus mehreren Festplatten</li>
<li>Fehlererkennung</li>
</ul>
</body>
</html>
